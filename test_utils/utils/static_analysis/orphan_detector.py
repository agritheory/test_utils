"""Detect dead/orphaned Python code using Vulture."""

import re
import subprocess
import sys
import tempfile
from dataclasses import dataclass, field
from pathlib import Path

VULTURE_LINE_RE = re.compile(
	r"^(?P<file>.+):(?P<line>\d+):\s+unused\s+(?P<kind>\S+)\s+'(?P<name>[^']+)'\s+\((?P<confidence>\d+)%\s+confidence\)$"
)

DEFAULT_IGNORE_PATTERNS = [
	"test_*",
	"*_fixtures",
	"setup",
	"teardown",
	"execute",
	"get_data",
	"get_list",
	"get_count",
	"get_form_dict",
]


@dataclass
class OrphanItem:
	file: str
	line: int
	kind: str
	name: str
	confidence: int

	def __str__(self) -> str:
		return f"{self.file}:{self.line}: unused {self.kind} '{self.name}' ({self.confidence}% confidence)"

	def to_dict(self) -> dict:
		return {
			"file": self.file,
			"line": self.line,
			"kind": self.kind,
			"name": self.name,
			"confidence": self.confidence,
		}


@dataclass
class OrphanResult:
	unreachable: list[OrphanItem] = field(default_factory=list)
	entry_points_found: int = 0
	error: str | None = None
	syntax_warnings: str | None = None

	def to_dict(self) -> dict:
		return {
			"unreachable": [item.to_dict() for item in self.unreachable],
			"entry_points_found": self.entry_points_found,
			"error": self.error,
			"syntax_warnings": self.syntax_warnings,
		}


def build_whitelist_source(entry_points: list[str]) -> str:
	lines = ["# Vulture whitelist generated by test_utils static analysis"]
	seen: set[str] = set()
	for ep in entry_points:
		name = ep.split(".")[-1]
		if name and name not in seen and name.isidentifier():
			seen.add(name)
			lines.append(name)
	return "\n".join(lines) + "\n"


def parse_vulture_output(output: str) -> list[OrphanItem]:
	items: list[OrphanItem] = []
	for line in output.splitlines():
		m = VULTURE_LINE_RE.match(line.strip())
		if m:
			items.append(
				OrphanItem(
					file=m.group("file"),
					line=int(m.group("line")),
					kind=m.group("kind"),
					name=m.group("name"),
					confidence=int(m.group("confidence")),
				)
			)
	return items


class OrphanDetector:
	"""
	Run Vulture against the app to detect unused code.

	Entry points (hooks paths, whitelisted functions, doctype controllers) are
	written to a temporary whitelist file so Vulture does not flag them as unused.
	"""

	def __init__(
		self,
		app_path: Path,
		min_confidence: int = 80,
		ignore_patterns: list[str] | None = None,
	) -> None:
		self.app_path = app_path
		self.min_confidence = min_confidence
		self.ignore_patterns: list[str] = (
			ignore_patterns if ignore_patterns is not None else list(DEFAULT_IGNORE_PATTERNS)
		)

	def detect(self, entry_points: list[str]) -> OrphanResult:
		result = OrphanResult(entry_points_found=len(entry_points))
		whitelist_source = build_whitelist_source(entry_points)

		with tempfile.NamedTemporaryFile(
			mode="w",
			suffix="_vulture_whitelist.py",
			prefix="test_utils_",
			delete=False,
		) as tmp:
			tmp.write(whitelist_source)
			whitelist_path = tmp.name

		try:
			cmd = [
				sys.executable,
				"-m",
				"vulture",
				str(self.app_path),
				whitelist_path,
				f"--min-confidence={self.min_confidence}",
			]
			if self.ignore_patterns:
				cmd += ["--ignore-names", ",".join(self.ignore_patterns)]

			proc = subprocess.run(cmd, capture_output=True, text=True, timeout=120)

			# exit 0: clean, 1: dead code found, 3: dead code found + syntax errors
			result.unreachable = parse_vulture_output(proc.stdout)
			if proc.returncode not in (0, 1, 3):
				result.error = f"vulture exited with code {proc.returncode}: {proc.stderr.strip()}"
			elif proc.returncode == 3 and proc.stderr.strip():
				result.syntax_warnings = proc.stderr.strip()
		except FileNotFoundError:
			result.error = "vulture not found â€” install it with: pip install vulture"
		except subprocess.TimeoutExpired:
			result.error = "vulture timed out after 120 seconds"
		finally:
			try:
				Path(whitelist_path).unlink(missing_ok=True)
			except Exception:
				pass

		return result
